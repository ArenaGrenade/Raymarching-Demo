(this.webpackJsonpportfolio=this.webpackJsonpportfolio||[]).push([[0],{138:function(e,n,t){},250:function(e,n,t){},251:function(e,n,t){"use strict";t.r(n);var r=t(13),i=t(0),o=t.n(i),a=t(62),c=t.n(a),s=(t(138),t(23)),l=t(28),d=t(11),u=function(e){var n=Object(s.d)(),t=(n.gl.domElement,n.camera,n.scene,n.clock),i=Object(s.e)((function(e){e.frustumCulled=!1}),[]),o=Object(s.c)(),a=Object(s.c)(),c=Object(s.c)(),u=Object(l.b)("Marching?",{type:"boolean",value:!0}),f=Object(l.b)("Power",{type:"number",value:1,min:1,max:10}),v=Object(l.b)("X",{type:"number",value:0,min:-3,max:3}),p=Object(l.b)("Y",{type:"number",value:0,min:-3,max:3}),h=Object(l.b)("Z",{type:"number",value:0,min:-3,max:3});return Object(s.b)((function(e){e.gl.domElement;var n,t,r=e.camera,c=e.clock;if(null===(n=i.current)||void 0===n||n.position.set(0,0,0),null===(t=a.current)||void 0===t||t.update(),r.updateProjectionMatrix(),u&&(o.current.onBeforeCompile=function(e){return o.current.userData.shader=e},o.current.userData.shader)){var s=Math.min(window.innerWidth,window.innerHeight);o.current.userData.shader.uniforms.resolution.value=new d.Vector2(s,s),o.current.userData.shader.uniforms.viewportSize.value=new d.Vector2(window.innerWidth,window.innerHeight),o.current.userData.shader.uniforms.time.value=c.elapsedTime,o.current.userData.shader.uniforms.power.value=f,o.current.userData.shader.uniforms.invTransformMat.value=(new d.Matrix4).set(1,0,0,-v,0,1,0,-p,0,0,1,-h,0,0,0,0)}})),Object(r.jsxs)(r.Fragment,{children:[Object(r.jsxs)("mesh",{ref:i,children:[Object(r.jsx)("planeGeometry",{args:[2,2],ref:c}),u?Object(r.jsx)("rawShaderMaterial",{args:[{uniforms:{resolution:{value:new d.Vector2(Math.min(window.innerWidth,window.innerHeight),Math.min(window.innerWidth,window.innerHeight))},viewportSize:{value:new d.Vector2(window.innerWidth,window.innerHeight)},time:{value:t.elapsedTime},power:{value:f},invTransformMat:{value:(new d.Matrix4).set(1,0,0,-v,0,1,0,-p,0,0,1,-h,0,0,0,1)}},vertexShader:"\n    attribute vec3 position;\n\n    void main(void) {\n        gl_Position = vec4(position, 1.0);\n    }\n",fragmentShader:"\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.0\n    #define SURF_DIST 0.001\n    #define PI 3.142\n\n    precision highp float;\n\n    uniform vec2 resolution;\n    uniform vec2 viewportSize;\n    uniform float time;\n    uniform float power;\n    uniform mat4 invTransformMat;\n\n    float atan2(in float y, in float x)\n    {\n        return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);\n    }\n\n    float signedDistToSphere(vec3 p, vec4 sphere) {\n        return length(sphere.xyz - p) - sphere.w;\n    }\n\n    float signedDistToBox(vec3 p, vec3 center, vec3 size) {\n        vec3 offset = abs(p - center) - size;\n        float unsignedDist = length(max(offset, 0.0));\n        float distInsideBox = min(max(offset.x, max(offset.y, offset.z)), 0.0);\n        return unsignedDist + distInsideBox;\n    }\n\n    float signedDistToRoundedbox(vec3 p, vec3 center, vec3 size, float smoothing) {\n        return signedDistToBox(p, center, size - vec3(smoothing)) - smoothing;\n    }\n\n    float signedDistToInfiniteCylinder(vec3 p, vec2 center, float radius) {\n        return length(p.xz - center) - radius;\n    }\n\n    float signedDistToPlane(vec3 p) {\n        return p.y;\n    }\n\n    float signedDistToMandelBulb(vec3 p) {\n        vec3 z = p;\n        float dr = 1.0;\n        float r;\n\n        for (int i = 0; i < 15; i++) {\n            r = length(z);\n            if (r > 2.0) break;\n\n            float theta = acos(z.z / r) * power;\n            float phi = atan2(z.y, z.x) * power;\n            float zr = pow(r, power);\n            dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n            z += p;\n        }\n\n        return 0.5 * log(r) * r / dr;\n    }\n\n    float smoothMin(float distA, float distB, float k) {\n        float h = max(k - abs(distA - distB), 0.0) / k;\n        return min(distA, distB) - h * h * h * k * 1.0 / 6.0;\n    }\n\n    vec3 transformPoint(vec3 p) {\n        return (invTransformMat * vec4(p, 1.0)).xyz;\n    }\n\n    float GetSceneDist(vec3 p) {\n        // float box = signedDistToBox(p, vec3(-1.5, 1, 6), vec3(1));\n        // float sphere = signedDistToSphere(p, vec4(1.5, 1, 6, 1));\n        // float plane = signedDistToPlane(p);\n        // float infCylinder = signedDistToInfiniteCylinder(p, vec2(0, 6), 0.5);\n        // float roundedBox = signedDistToRoundedbox(p, vec3(-1.5, 1, 6), vec3(1), 0.0);\n\n        vec3 transformed = transformPoint(p);\n        float mandelBulb = signedDistToMandelBulb(transformed);\n\n        return mandelBulb;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd) {\n        float d0 = 0.0;\n\n        for (int i = 0; i < MAX_STEPS; i++) {\n            vec3 p = ro + rd * d0;\n            float dS = GetSceneDist(p);\n            d0 += dS;\n\n            if (d0 > MAX_DIST || abs(dS) < SURF_DIST) break;\n        }\n\n        return d0;\n    }\n\n    vec3 CalculateNormal (vec3 p) {\n        float d = GetSceneDist(p);\n        vec2 e = vec2(0.01, 0);\n\n        vec3 n = d - vec3(\n            GetSceneDist(p - e.xyy),\n            GetSceneDist(p - e.yxy),\n            GetSceneDist(p - e.yyx)\n        );\n\n        return normalize(n);\n    }\n\n    float CalculateLighting (vec3 p) {\n        vec3 lightPos = vec3(0, 0.6, -2);\n        vec3 l = normalize(lightPos - p);\n\n        vec3 n = CalculateNormal(p);\n\n        float diffuse = clamp(dot(n, l), 0.0, 1.0);\n\n        float d = RayMarch(p + n * SURF_DIST * 2.0, l);\n        if (d < length(lightPos - p)) diffuse *= 0.1;\n\n        return diffuse;\n    }\n\n    void main(void) {\n        // Get the scaled screen space coordinate\n        vec2 uv = (gl_FragCoord.xy - 0.5 * viewportSize) / resolution;\n\n        // Convert the ray direction from normalized screen coordinate to world space coordinate\n        vec3 ray = normalize(vec3(uv.x, uv.y, 1));\n\n        // Get Camera Position\n        vec3 cPos = vec3(0, 0, -5);\n\n        // Cast the ray and calculate the color\n        vec3 col = vec3(0.0);\n        float d = RayMarch(cPos, ray);\n\n        vec3 p = cPos + ray * d;\n        float litColor = CalculateLighting(p);\n        col = vec3(litColor);\n\n        gl_FragColor = vec4(col, 1.0);\n    }\n"}],ref:o}):Object(r.jsx)("meshBasicMaterial",{args:[{color:16711680,side:d.DoubleSide}]})]}),i.current&&Object(r.jsx)("boxHelper",{args:[i.current,16776960],ref:a})]})},f=function(e){var n=Object(s.d)(),t=n.gl,o=n.camera,a=n.forceResize;return Object(i.useEffect)((function(){o.near=0,o.far=4e3,o.position.set(0,0,0),o.updateProjectionMatrix(),t.setSize(window.innerWidth,window.innerHeight),t.setPixelRatio(window.devicePixelRatio),a()}),[]),Object(s.b)((function(e){var n=e.gl.domElement,t=e.camera;t.left=-n.width/2,t.right=n.width/2,t.top=n.height/2,t.bottom=-n.height/2,t.updateProjectionMatrix()})),Object(r.jsxs)(r.Fragment,{children:[Object(r.jsx)(u,{}),Object(r.jsx)("axesHelper",{args:[300]})]})},v=(t(250),Object(l.c)(s.a)),p=function(){return Object(r.jsxs)(l.a.Provider,{children:[Object(r.jsx)(v,{orthographic:!0,camera:[-1,1,1,-1,0,1],children:Object(r.jsx)(f,{})}),Object(r.jsx)(l.a,{width:320})]})},h=function(e){e&&e instanceof Function&&t.e(3).then(t.bind(null,254)).then((function(n){var t=n.getCLS,r=n.getFID,i=n.getFCP,o=n.getLCP,a=n.getTTFB;t(e),r(e),i(e),o(e),a(e)}))};c.a.render(Object(r.jsx)(o.a.StrictMode,{children:Object(r.jsx)(p,{})}),document.getElementById("root")),h()}},[[251,1,2]]]);
//# sourceMappingURL=main.0892a23d.chunk.js.map